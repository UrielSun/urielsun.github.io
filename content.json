{"meta":{"title":"奋斗的小土豆个人博客","subtitle":"","description":"奋斗的小土豆个人博客网站","author":"奋斗的小土豆","url":"http://yoursite.com"},"pages":[{"title":"Dagger2使用详记","date":"2017-08-12T13:27:42.000Z","updated":"2019-09-26T03:17:34.062Z","comments":true,"path":"dagger2.html","permalink":"http://yoursite.com/dagger2.html","excerpt":"1234567# Hello, Dagger2&gt; A fast dependency injector for Android and Java.##### 1. 什么是Dagger2?&gt; Google: Dagger 2 is a compile-time evolution approach to dependency injection. Taking the approach started in Dagger 1.x to its ultimate conclusion, Dagger 2.x eliminates all reflection, and improves code clarity by removing the traditional ObjectGraph/Injector in favor of user-specified @Component interfaces.- Android和java的快速依赖注入，在编译期间自动生成代码，负责依赖对象的创建。另外，以Dagger 1.x开始的方法达到其最终结论，Dagger 2.x消除了所有反射，并且通过移除传统的ObjectGraph / Injector而改进了代码清晰度，而改为用户指定的@Component接口。大概意思就是Dagger2使用过程中性能消耗上控制的很好，没使用反射，所有的注解均停留在编译时期。","text":"1234567# Hello, Dagger2&gt; A fast dependency injector for Android and Java.##### 1. 什么是Dagger2?&gt; Google: Dagger 2 is a compile-time evolution approach to dependency injection. Taking the approach started in Dagger 1.x to its ultimate conclusion, Dagger 2.x eliminates all reflection, and improves code clarity by removing the traditional ObjectGraph/Injector in favor of user-specified @Component interfaces.- Android和java的快速依赖注入，在编译期间自动生成代码，负责依赖对象的创建。另外，以Dagger 1.x开始的方法达到其最终结论，Dagger 2.x消除了所有反射，并且通过移除传统的ObjectGraph / Injector而改进了代码清晰度，而改为用户指定的@Component接口。大概意思就是Dagger2使用过程中性能消耗上控制的很好，没使用反射，所有的注解均停留在编译时期。 1234567891011121314151617181920212223242526272829303132333435363738394041##### 2. 为什么使用Dagger2?&gt; Dependency injection (as a pattern not a library) benefits almost all code. Both performance / extending / testable and etc.- 增加开发效率、省去重复的简单体力劳动&gt; 首先new一个实例的过程是一个重复的简单体力劳动，dagger2完全可以把new一个实例的工作做了，因此我们把主要精力集中在关键业务上、同时也能增加开发效率上。 省去写单例的方法，并且也不需要担心自己写的单例方法是否线程安全，自己写的单例是懒汉模式还是饿汉模式。因为dagger2都可以把这些工作做了。- 更好的管理类实例&gt; 每个app中的ApplicationComponent管理整个app的全局类实例，所有的全局类实例都统一交给ApplicationComponent管理，并且它们的生命周期与app的生命周期一样。 每个页面对应自己的Component，页面Component管理着自己页面所依赖的所有类实例。 因为Component，Module，整个app的类实例结构变的很清晰。- 解耦&gt; 假如不用dagger2的话，一个类的new代码是非常可能充斥在app的多个类中的，假如该类的构造函数发生变化，那这些涉及到的类都得进行修改。设计模式中提倡把容易变化的部分封装起来。在使用Dagger2后,通过用注解标注的构造函数创建类实例，则即使构造函数变的天花乱坠，我们基本上都不需要修改任何代码。[Demo Code](file:///Users/Vincent/Github/AndroidCodeBuckets/AndroidDagger2/app/src/main/java/me/onez/androiddagger2/DemoNoDagger2Activity.kt)##### 3. Dagger2 API​```javapublic @interface Component &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; Class&lt;?&gt;[] dependencies() default &#123;&#125;;&#125;public @interface Subcomponent &#123; Class&lt;?&gt;[] modules() default &#123;&#125;;&#125;public @interface Module &#123; Class&lt;?&gt;[] includes() default &#123;&#125;;&#125;public @interface Provides &#123;&#125;public @interface MapKey &#123; boolean unwrapValue() default true;&#125;public interface Lazy&lt;T&gt; &#123; T get();&#125;​ Dagger2中用到的定义在Java依赖注入标准(JSR-330)中的元素​123456789public @interface Inject &#123;&#125;public @interface Scope &#123;&#125;public @interface Qualifier &#123;&#125;​ @Inject 标记那些应该被依赖注入框架提供的依赖。Dagger2中有以下3种方式提供依赖: 构造器注入 直接注入构造器,告诉Dagger2可以使用这个构造器构建对象 注入构造器所需要的参数的依赖局限性: 如果有多个构造器，我们只能标注其中一个，无法标注多个 [Demo Code](file:///Users/Vincent/Github/AndroidCodeBuckets/AndroidDagger2/app/src/main/java/me/onez/androiddagger2/Presenter.kt) 方法注入 该方法不能是抽象方法，不能用private修饰 123456private lateinit var dependencyA: DependencyA@Injectfun setDenpendencyA(dependencyA: DependencyA) &#123; this.dependencyA = dependencyA&#125; 如果目的是注入属性的话，方法注入和属性注入基本没有区别，属性注入是Dagger2中使用最多的一个注入方式。但是在某些特殊情况下会用到方法注入，如当我们希望传入类的当前实例（this引用）到被注入的依赖中。方法注入会在构造器调用后马上被调用，所以这表示我们可以传入完全被构造的this。 属性注入 注解在属性中表示该属性需要依赖注入，不能使用private修饰 12@Injectlateinit var presenter: Presenter Dagger2容器先调用属性注入，然后再方法注，如:​12345678 @Inject lateinit var dependencyA: DependencyA @Inject fun setDenpendencyA(dependencyA: DependencyA) &#123; this.dependencyA = dependencyA &#125;​ dependencyA 会注入两次,两次注入的 dependencyA 也不相同 @Module 使用@Inject标记构造器提供依赖是有局限性的，比如说我们需要注入的对象是第三方库提供的，我们无法在第三方库的构造器上加上@Inject注解。 或者，我们使用依赖倒置的时候，因为需要注入的对象是抽象的，@Inject也无法使用，因为抽象的类并不能实例化，所以该注解与@Provides结合为Dagger2提供依赖关系，用于不能用@Inject提供依赖的地方。 @Provides @Provides仅能注解方法，且方法所在类要有@Module注解。注解后的方法表示Dagger2能用该方法实例对象提供依赖。按照惯例，@Provides方法的命名以provide为前缀，方便阅读管理。 Demo Code @Component 一般用来注解接口，被注解的接口在编译时会生成相应的实例，实例名称一般以Dagger为前缀，作为所需注入依赖和提供依赖之间的桥梁，把提供的依赖注入到所需注入的依赖中。Component中一般使用两种方式定义方法: void inject(目标类 obj):Dagger2会从目标类开始查找@Inject注解，自动生成依赖注入的代码，调用inject可完成依赖的注入。 Object getObj():Dagger2会到提供依赖注入类中找被@Inject注解标注的构造器，自动生成提供注入类的依赖的代码，这种方式一般为其他Component提供依赖。Componet可以指定多个module,也可以依赖其他Component @Component中的依赖: dependency Demo Code @Subcomponent dependency和@SubComponent都可以实现相同的依赖结果，@SubComponent更多用于其subcomponent作为component的扩展的时候。譬如很多工具类都需要使用到Application的Context对象，此时就可以用一个Component负责提供，我们可以命名为AppComponent。需要用到的context对象的SharePreferenceComponent，ToastComponent就可以它作为Subcomponent存在了。而在AppComponent中，我们可以很清晰的看到有哪些子Component。 Demo Code Component dependencies和SubComponent区别 Component dependencies 能单独使用，而Subcomponent必须由Component调用方法获取。 Component dependencies 可以很清楚的得知他依赖哪个Component， 而Subcomponent不能 @Qualifier和@Named @Qualifier是限定符，而@Named则是基于String的限定符。当我有两个相同的依赖（都继承某一个父类或者都是先某一个接口）可以提供给高层时，那么程序就不知道我们到底要提供哪一个依赖，因为它找到了两个。这时候我们就可以通过限定符为两个依赖分别打上标记，指定提供某个依赖。Demo Code @Qualifier的作用和@Named是完全一样的，不过更推荐使用@Qualifier，因为@Named需要手写字符串，容易出错。 @Qualifier不是直接注解在属性上的，而是用来自定义注解的。Demo Code @Scope和@Singleton @Scope和@Singleton，控制所提供依赖的生命周期，使提供的依赖可以做到与视图的生命周期相同、局部单例或者是全局单例等。而@Singleton则是@Scope的默认实现。Demo Code 父Component有scope则子Component也必须有scope，而且不能和父scope一样 @Scope是需要成对存在的，在Module的Provide方法中使用了@Scope，那么对应的Component中也必须使用@Scope注解，当两边的@Scope名字一样时（比如同为@Singleton）, 那么该Provide方法提供的依赖将会在Component中保持“局部单例”。而在Component中标注@Scope，provide方法没有标注，那么这个Scope就不会起作用，而Component上的Scope的作用也只是为了能顺利通过编译 单例实现方式: 依赖在Component中是单例的（供该依赖的provide方法和对应的Component类使用同一个Scope注解。） 对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象。（在Application中创建该Component） 使用总结: @Component关联的@Module中的任何一个@Provides有@scope，则该整个@Component要加上这个scope。否则在暴露或者注入时会报错 @Component的dependencies与@Component自身的scope不能相同，即组件之间的scope不能相同 @Singleton的组件不能依赖其他scope的组件，但是其他scope的组件可以依赖@Singleton组件 没有scope的不能依赖有scope的组件 一个component不能同时有多个scope(Subcomponent除外) 12转自我朋友 asker517"},{"title":"","date":"2019-06-13T07:22:45.460Z","updated":"2018-10-16T00:50:00.491Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://yoursite.com/photos/lazyload.min.js","excerpt":"","text":""},{"title":"","date":"2019-06-14T10:25:17.501Z","updated":"2019-06-14T10:25:17.501Z","comments":true,"path":"photos/ins.css","permalink":"http://yoursite.com/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 23%; height: 0; margin: 4px; padding-bottom: 23%; position: relative; display: inline-block; text-align: center; background: #ffffff; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 48%; padding-bottom: 48%; margin: 1%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"相册","slug":"photos","date":"2019-06-14T09:34:17.313Z","updated":"2019-06-14T09:34:17.313Z","comments":false,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":"相册加载中，请稍后 (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2019-06-23T15:54:21.723Z","updated":"2019-06-23T15:54:21.723Z","comments":true,"path":"photos/ins.json","permalink":"http://yoursite.com/photos/ins.json","excerpt":"","text":"{\"list\":[{\"date\":\"2019-06\",\"arr\":{\"year\":2019,\"month\":6,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"http://pt2ku9jqo.bkt.clouddn.com/redflower.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/redflower2.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/whiteflower.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/whiteflowr2.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/roteflower.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/tree.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/meihua.jpg\"],\"height_width\":[[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456]],\"text\":[\"春天总是那样的充满生机，花儿总是开的那样的绚烂\",\"走在开满花的道路上，总是那么的心旷神怡\",\"红的，白的，粉的，各式各样，真相斗艳\",\"不知是樱花还是桃花\",\"走在铺满了鲜花道路上\",\"树苗长出了新芽\",\"梅花含苞待放\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2019-05\",\"arr\":{\"year\":2019,\"month\":5,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6604.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6632.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6640.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6606.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6596.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6566.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6565.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6561.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6586.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6545.jpg\",\"http://pt2ku9jqo.bkt.clouddn.com/IMG_6514.jpg\"],\"height_width\":[[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456],[5184,3456]],\"text\":[\"天空总是那么的开阔\",\"天空总是那么的蔚蓝\",\"天空总是那么多姿多彩\",\"云朵的形状总是变换莫测\",\"有的像棉花糖\",\"有的像沙滩\",\"有的像海洋\",\"有的像沙漠\",\"\",\"\",\"\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}}]}"},{"title":"","date":"2019-06-23T15:54:03.929Z","updated":"2019-06-23T15:52:50.140Z","comments":true,"path":"photos/ins.js","permalink":"http://yoursite.com/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = data.link[i]+\"?imageView2/1/w/200\"; var src = data.link[i]; var type = data.type[i]; var height = data.height_width[i][0]; var width =data.height_width[i][1]; var target = src; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './ins.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"}],"posts":[{"title":"Flutter 页面间数据传递(共享)的几种常用方式","slug":"Flutter页面间数据传递(共享)的几种常用方式","date":"2019-08-08T03:15:57.000Z","updated":"2019-09-26T05:02:17.196Z","comments":true,"path":"2019/08/08/Flutter页面间数据传递(共享)的几种常用方式/","link":"","permalink":"http://yoursite.com/2019/08/08/Flutter页面间数据传递(共享)的几种常用方式/","excerpt":"前言 &nbsp;&nbsp;&nbsp;&nbsp;在Android中，我们常遇到的场景就是在页面跳转(Frament,Activity)时候，要将当前的部分数据携带到另外一个页面中，供另外页面使用。这时候我们常用的就是使用Intent， Bundle等携带数据。 &nbsp;&nbsp;&nbsp;&nbsp;那么在Flutter的开发过程中，页面之间的数据传递也是必不可少的，又是怎么把一个页面的数据传递(共享)给另外一个页面，或者关闭当前页面并把当前页面的数据带给前一个页面。 &nbsp;&nbsp;&nbsp;&nbsp;本篇文章将会介绍Flutter中，页面面之间的数据传递(共享)的几种常见方式及场景。 ​ 在开始数据传递之前我们先创建一个传递数据的类 在Android中传递对象我们需要序列化实现Serializable或者Parcelable接口才能被传递，在Flutter中数据传递没有序列化的方法，直接就可以传递对象。定义一个简单的类如下： 12345678///用来传递数据的实体class TransferDataEntity &#123; String name; String id; int age; TransferDataEntity(this.name, this.id, this.age);&#125;","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;在Android中，我们常遇到的场景就是在页面跳转(Frament,Activity)时候，要将当前的部分数据携带到另外一个页面中，供另外页面使用。这时候我们常用的就是使用Intent， Bundle等携带数据。 &nbsp;&nbsp;&nbsp;&nbsp;那么在Flutter的开发过程中，页面之间的数据传递也是必不可少的，又是怎么把一个页面的数据传递(共享)给另外一个页面，或者关闭当前页面并把当前页面的数据带给前一个页面。 &nbsp;&nbsp;&nbsp;&nbsp;本篇文章将会介绍Flutter中，页面面之间的数据传递(共享)的几种常见方式及场景。 ​ 在开始数据传递之前我们先创建一个传递数据的类 在Android中传递对象我们需要序列化实现Serializable或者Parcelable接口才能被传递，在Flutter中数据传递没有序列化的方法，直接就可以传递对象。定义一个简单的类如下： 12345678///用来传递数据的实体class TransferDataEntity &#123; String name; String id; int age; TransferDataEntity(this.name, this.id, this.age);&#125; 我们具体看看数据传递的方式 通过构造器(constructor)传递数据&nbsp;&nbsp;&nbsp;&nbsp;通过构造器传递数据是一种最简单的方式，也是最常用的方式，在第一个页面，我们模拟创建一个我们需要传递数据的对象。当点击跳转的时候，我们把数据传递给DataTransferByConstructorPage页面，并把携带过来的数据展示到页面上。 创建一个传递数据对象 1final data = TransferDataEntity(\"001\", \"张三丰\", 18); 定义一个跳转到DataTransferByConstructorPage页面的方法 123456_transferDataByConstructor(BuildContext context, TransferDataEntity data) &#123; Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; DataTransferByConstructorPage(data: data))); &#125; 在DataTransferByConstructorPage页面接收到数据并展示出来，代码如下 我们只需要做两件事： 1.提供一个final变量 final TransferDataEntity data 2.提供一个构造器接收参数 DataTransferByConstructorPage({this.data}); 12345678910111213141516171819202122232425262728293031323334353637///通过构造器的方式传递参数class DataTransferByConstructorPage extends StatelessWidget &#123; final TransferDataEntity data; DataTransferByConstructorPage(&#123;this.data&#125;); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"构造器方式\"), ), body: Column( children: &lt;Widget&gt;[ Container( width: double.infinity, height: 40.0, alignment: Alignment.center, child: Text(data.id), ), Container( width: double.infinity, height: 40.0, alignment: Alignment.center, child: Text(data.name), ), Container( width: double.infinity, height: 40.0, alignment: Alignment.center, child: Text(\"$&#123;data.age&#125;\"), ) ], ), ); &#125;&#125; ​ 当一个页面关闭时携带数据到上一个页面（Navigator.pop） 在Android开发中我们需要将数据传递给上一个页面通常使用的传统方式是startActivityForResult()方法。但是在flutter就不用这么麻烦了。只需要使用Navigator.pop方法即可将数据结果带回去。但是我们跳转的时候需要注意两点: ​ 1.我们需要定义一个异步方法用于接收返回来的结果 1234567///跳转的时候我们需要使用异步等待回调结果 dataFromOtherPage 就是返回的结果_toTransferForResult(BuildContext context, TransferDataEntity data) async &#123; final dataFromOtherPage = await Navigator.push( context, MaterialPageRoute(builder: (context) =&gt; TransferRouterPage(data: data)), ) as TransferDataEntity; &#125; ​ 2.在我们要关闭的页面使用Navigator.pop 返回第一个页面 12345//返回并携带数据 _backToData(BuildContext context)&#123; var transferData = TransferDataEntity(&quot;嘻嘻哈哈&quot;,&quot;007&quot;,20); Navigator.pop(context,transferData); &#125; ​ InheritedWidget方式 官网给出的解释：InheritedWidget是Flutter中非常重要的一个功能型Widget，它可以高效的将数据在Widget树中向下传递、共享，这在一些需要在Widget树中共享数据的场景中非常方便，如Flutter中，正是通过InheritedWidget来共享应用主题(Theme)和Locale(当前语言环境)信息的。 InheritedWidget和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在Widget树中数据传递方向是从上到下的，这和Notification的传递方向正好相反。 优点：可以控制每个Widget单独去取数据并使用 如果一个页面只存在同一层级的Weiget这时候使用构造器的方式当然是最简单的，也是最方便的，但是如果一个页面存在多个层级的Weiget这时候构造器的方法就有了局限性，这时候我们使用InheritedWidget 是一个比较好的选择。 使用InheritedWidget方式如下几步： 继承InheritedWidget提供一个数据源 12345678910111213141516class IDataProvider extends InheritedWidget&#123; final TransferDataEntity data; IDataProvider(&#123;Widget child,this.data&#125;):super(child:child); @override bool updateShouldNotify(IDataProvider oldWidget) &#123; return data!=oldWidget.data; &#125; static IDataProvider of(BuildContext context)&#123; return context.inheritFromWidgetOfExactType(IDataProvider); &#125;&#125; 定义页面跳转时候携带数据的方法 12345678910///跳转到IDataWidget页面并携带数据_inheritedToPage(BuildContext context, TransferDataEntity data) &#123; Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; IDataProvider( child: IDataWidget(), data: data, ))); &#125; 跳转的到的页面并展示数据代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142class IDataWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final data = IDataProvider.of(context).data; return Scaffold( appBar: AppBar( title: Text(\"Inherited方式传递数据\"), ), body: Column( children: &lt;Widget&gt;[ Container( alignment: Alignment.center, height: 40.0, child: Text(data.name), ), Container( alignment: Alignment.center, height: 40.0, child: Text(data.id), ), Container( alignment: Alignment.center, height: 40.0, child: Text(\"$&#123;data.age&#125;\"), ), IDataChildWidget() ], ), ); &#125;&#125;class IDataChildWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final data = IDataProvider.of(context).data; return Container( child: Text(data.name), ); &#125;&#125; ​ 我们将上面的IDataProvier进行改造加入泛型就可以通用了 1.修改后的Provider类如下 12345678910111213141516class IGenericDataProvider&lt;T&gt; extends InheritedWidget &#123; final T data; IGenericDataProvider(&#123;Key key, Widget child, this.data&#125;) : super(key: key, child: child); @override bool updateShouldNotify(IGenericDataProvider oldWidget) &#123; return data != oldWidget.data; &#125; static T of&lt;T&gt;(BuildContext context) &#123; return (context.inheritFromWidgetOfExactType( IGenericDataProvider&lt;T&gt;().runtimeType) as IGenericDataProvider&lt;T&gt;).data; &#125;&#125; 2.使用跳转的时候修改代码如下(主要是添加泛型支持) 123456789_inheritedGenericToPage(BuildContext context, TransferDataEntity data) &#123; Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; IGenericDataProvider&lt;TransferDataEntity&gt;( child: IDataWidget(), data: data, ))); &#125; ​ 接收传递的值的方式如下 IGenericDataProvider.of(context) 可以直接取值 12345678910111213141516171819202122232425262728293031class IGenericDataWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final data = IGenericDataProvider.of&lt;TransferDataEntity&gt;(context); return Scaffold( appBar: AppBar( title: Text(\"Inherited泛型方式传递数据\"), ), body: Column( children: &lt;Widget&gt;[ Container( alignment: Alignment.center, height: 40.0, child: Text(data.name), ), Container( alignment: Alignment.center, height: 40.0, child: Text(data.id), ), Container( alignment: Alignment.center, height: 40.0, child: Text(\"$&#123;data.age&#125;\"), ), ], ), ); &#125;&#125; ​ 全局的提供数据的方式 这种方式我们还是使用InheritedWidget，区别就是我们不是跳转的时候去创建IGenericDataProvider。而是把他放在最顶层 注意：这种方式一定要把数据放在顶层 ​ 定义顶部数据 12345678910111213141516171819class MyApp extends StatelessWidget &#123; // This widget is the root of your application. //传递值的数据 var params = InheritedParams(); @override Widget build(BuildContext context) &#123; return IGenericDataProvider( data: params, child: MaterialApp( title: 'Data Transfer Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Data Transfer Demo'), ), ); &#125;&#125; ​ 接收数据的方式基本和InheritedWidget相同 final data = IGenericDataProvider.of(context)，获取数据 1234567891011121314151617181920212223242526272829303132333435class InheritedParamsPage extends StatefulWidget &#123; @override _InheritedParamsPageState createState() =&gt; _InheritedParamsPageState();&#125;class _InheritedParamsPageState extends State&lt;InheritedParamsPage&gt; &#123; @override Widget build(BuildContext context) &#123; final data = IGenericDataProvider.of&lt;TransferDataEntity&gt;(context); return Scaffold( appBar: AppBar( title: Text(\"通过全局数据方式\"), ), body:Column( children: &lt;Widget&gt;[ Container( alignment: Alignment.center, height: 40.0, child: Text(data.name), ), Container( alignment: Alignment.center, height: 40.0, child: Text(data.id), ), Container( alignment: Alignment.center, height: 40.0, child: Text(\"$&#123;data.age&#125;\"), ), ], ), ); &#125;&#125; ​ 通过全局单例模式来使用 这种方式就是创建一个全局单例对象，任何地方都可以操控这个对象，存储和取值都可以通过这个对象 ​ 创建单例对象 1234567891011121314class TransferDataSingleton &#123; static final TransferDataSingleton _instanceTransfer = TransferDataSingleton.__internal(); TransferDataEntity transData; factory TransferDataSingleton() &#123; return _instanceTransfer; &#125; TransferDataSingleton.__internal();&#125;final transSingletonData = TransferDataSingleton(); ​ 给单例对象存放数据 123456_singletonDataTransfer(BuildContext context) &#123; var transferData = TransferDataEntity(\"二汪\", \"002\", 25); transSingletonData.transData = transferData; Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; TransferSingletonPage())); &#125; ​ 接收并使用传递的值 123456789101112131415161718192021222324252627282930313233343536class TransferSingletonPage extends StatefulWidget &#123; @override _TransferSingletonPageState createState() =&gt; _TransferSingletonPageState();&#125;class _TransferSingletonPageState extends State&lt;TransferSingletonPage&gt; &#123; @override Widget build(BuildContext context) &#123; //直接引入单例对象使用 var data = transSingletonData.transData; return Scaffold( appBar: AppBar( title: Text(\"全局单例传递数据\"), ), body: Column( children: &lt;Widget&gt;[ Container( alignment: Alignment.center, height: 40.0, child: Text(data.name), ), Container( alignment: Alignment.center, height: 40.0, child: Text(data.id), ), Container( alignment: Alignment.center, height: 40.0, child: Text(\"$&#123;data.age&#125;\"), ), ], ), ); &#125;&#125; ​ 全局单例结合Stream的方式传递数据 创建一个接受全局的单例对象，并把传递值转成Stream方式 在接收数据可以使用StreamBuilder直接接收并处理 123456789101112131415161718class TransferStreamSingleton &#123; static final TransferStreamSingleton _instanceTransfer = TransferStreamSingleton.__internal(); StreamController streamController; void setTransferData(TransferDataEntity transData) &#123; streamController = StreamController&lt;TransferDataEntity&gt;(); streamController.sink.add(transData); &#125; factory TransferStreamSingleton() &#123; return _instanceTransfer; &#125; TransferStreamSingleton.__internal();&#125;final streamSingletonData = TransferStreamSingleton(); ​ 传递要携带的数据 123456_streamDataTransfer(BuildContext context) &#123; var transferData = TransferDataEntity(\"三喵\", \"005\", 20); streamSingletonData.setTransferData(transferData); Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; TransferStreamPage())); &#125; ​ 接收要传递的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TransferStreamPage extends StatefulWidget &#123; @override _TransferStreamPageState createState() =&gt; _TransferStreamPageState();&#125;class _TransferStreamPageState extends State&lt;TransferStreamPage&gt; &#123; StreamController _streamController = streamSingletonData.streamController; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"全局单例结合Stream\"), ), body: StreamBuilder( stream: _streamController.stream, initialData: TransferDataEntity(\"\", \"\", 0), builder: (context, snapshot) &#123; return Column( children: &lt;Widget&gt;[ Container( alignment: Alignment.center, height: 40.0, child: Text(snapshot.data.name), ), Container( alignment: Alignment.center, height: 40.0, child: Text(snapshot.data.id), ), Container( alignment: Alignment.center, height: 40.0, child: Text(\"$&#123;snapshot.data.age&#125;\"), ), ], ); &#125;)); &#125; @override void dispose() &#123; _streamController.close(); super.dispose(); &#125;&#125; ​ 总结 &nbsp;&nbsp;&nbsp;&nbsp;以上是我们在在Flutter中常用的几种页面之间传递数据的方式，其中最后一种方式提到了Stream和StreamBuilder我有一篇文章专门介绍了Flutter的Stream。Flutter Stream简介及使用 详细的介绍了Stream及部分操作的使用。 &nbsp;&nbsp;&nbsp;&nbsp;现在官方推荐的provider实际上就是使用了InheritedWidget有时间的话建议详细了下InheritedWidget及使用方法。 &nbsp;&nbsp;&nbsp;&nbsp;以上是对页面之间值传递的一个总结，本文Demo，如有写的不足之处，望指正~","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"数据传递","slug":"数据传递","permalink":"http://yoursite.com/tags/数据传递/"},{"name":"数据共享","slug":"数据共享","permalink":"http://yoursite.com/tags/数据共享/"}]},{"title":"Flutter Stream 简介及部分操作符使用","slug":"Flutter Stream 简介及部分操作符使用","date":"2019-07-26T02:49:15.000Z","updated":"2019-09-26T03:10:00.880Z","comments":true,"path":"2019/07/26/Flutter Stream 简介及部分操作符使用/","link":"","permalink":"http://yoursite.com/2019/07/26/Flutter Stream 简介及部分操作符使用/","excerpt":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于刚接触Flutter的同学来说,Stream(流)是一个相对比较抽象，也相对比较难以理解的东西。准确的来说Stream并不是Flutter的特性，而是Dart语言自身所带库。Stream和Future都位于dart:async核心库，是Dart中异步操作的两大高手。所以不仅仅可以用于Flutter,而是可以用于任何Dart语言上的实现。 &nbsp;&nbsp;&nbsp;&nbsp;在我们刚开始学习Flutter的时候基本都是使用 StatefulWidget和setState((){})来刷新界面的数据，当我熟练使用流之后就可以基本完全使用StatelessWidget告别 StatefulWidget同样达到数据刷新效果。 ​ Stream分类流可以分为两类： 单订阅流(Single Subscription),这种流最多只能有一个监听器(listener) 多订阅流(Broadcast),这种流可以有多个监听器监听（listener）","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于刚接触Flutter的同学来说,Stream(流)是一个相对比较抽象，也相对比较难以理解的东西。准确的来说Stream并不是Flutter的特性，而是Dart语言自身所带库。Stream和Future都位于dart:async核心库，是Dart中异步操作的两大高手。所以不仅仅可以用于Flutter,而是可以用于任何Dart语言上的实现。 &nbsp;&nbsp;&nbsp;&nbsp;在我们刚开始学习Flutter的时候基本都是使用 StatefulWidget和setState((){})来刷新界面的数据，当我熟练使用流之后就可以基本完全使用StatelessWidget告别 StatefulWidget同样达到数据刷新效果。 ​ Stream分类流可以分为两类： 单订阅流(Single Subscription),这种流最多只能有一个监听器(listener) 多订阅流(Broadcast),这种流可以有多个监听器监听（listener） Stream创建方式 Stream.fromFuture 接收一个Future对象作为参数 123456Stream&lt;String&gt;.fromFuture(getData());Future&lt;String&gt; getData() async&#123; await Future.delayed(Duration(seconds: 5)); return \"返回一个Future对象\"; &#125; ​ Stream.fromIterable 接收一个集合对象作为参数 1Stream&lt;String&gt;.fromIterable(['A','B','C']); ​ Stream.fromFutures 接收一个Future集合对象作为参数 1Stream&lt;String&gt;.fromFutures([getData()]); ​ Stream.periodic 接收一个 Duration对象作为参数 12Duration interval = Duration(seconds: 1);Stream&lt;int&gt; stream = Stream&lt;int&gt;.periodic(interval); ​ 操作方式及使用使用Stream .periodic 方式创建一个Stream对象 用于创建一个周期发送事件的流，如下 12345678910///用于创建一个每隔一秒发送一次无限事件的流,并打印出值void _stream() async&#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); await for(int i in stream )&#123; print(i); &#125;&#125;//(data)&#123;return data;&#125; 上面的这句是用来回来值，如果省略这句，打印的值都为null . Stream.take(int count) 上面创建了一个无限每隔一秒发送一次事件的流，如果我们想指定只发送10个事件则，用take。下面就只会打印出0-9 12345678void _stream() async&#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); //指定发送事件个数 await for(int i in stream )&#123; print(i); &#125;&#125; ​ Stream.takeWhile 上面这种方式我们是只制定了发送事件的个数，如果我们也不知道发送多少个事件，我们可以从返回的结果上做一个返回值的限制,上面结果也可以用以下方式实现 1234567891011void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data);// stream = stream.take(10); stream = stream.takeWhile((data) &#123; return data &lt; 10; &#125;); await for (int i in stream) &#123; print(i); &#125; &#125; ​ Stream.skip(int count) skip可以指定跳过前面的几个事件,如下会跳过0和1，输出 2-9; 123456789void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); stream = stream.skip(2); await for (int i in stream) &#123; print(i); &#125; &#125; ​ Stream.skipWhile 可以指定跳过不发送事件的指定条件，如下跳过0-4的输出，输出5-9 123456789void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); stream = stream.skipWhile((data) =&gt; data&lt;5); await for (int i in stream) &#123; print(i); &#125; &#125; ​ Stream.toList() 将流中所有的数据收集存放在List中，并返回 Future&lt;List&gt;对象，listData里面 0-9 1.这个是一个异步方法，要结果则需要使用await关键字 2.这个是等待Stream当流结束时，一次返回结果 123456789void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); List&lt;int&gt; listData = await stream.toList(); for (int i in listData) &#123; print(i); &#125; &#125; ​ Stream. listen() 这是一种特定的可以用于监听数据流的方式，和 forEach循环的效果一致，但是返回的是StreamSubscription&lt;T&gt;对象，如下也会输出0-9,同时打印出 ”流已完成“ 看一下源码这种方式可以接收 123&gt; StreamSubscription&lt;T&gt; listen(void onData(T event),&gt; &#123;Function onError, void onDone(), bool cancelOnError&#125;);&gt; 1.onData是接收到数据的处理,必须要实现的方法 2.onError流发生错误时候的处理 3.onDone流完成时候调取 4.cancelOnError发生错误的时候是否立马终止 123456789101112void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); stream.listen((data) &#123; print(data); &#125;, onError: (error) &#123; print(\"流发生错误\"); &#125;, onDone: () &#123; print(\"流已完成\"); &#125;, cancelOnError: false); &#125; ​ Stream. forEach() 这中操作和listen()的方式基本差不多，也是一种监听流的方式，这只是监听了onData,下面代码也会输出0-9 12345678void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); stream.forEach((data) &#123; print(data); &#125;); &#125; ​ Stream .length 用于获取等待流中所有事件发射完成之后统计事件的总数量,下面代码会输出 10 1234567void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.take(10); var allEvents = await stream.length; print(allEvents); &#125; ​ Stream.where 在流中添加筛选条件，过滤掉一些不想要的数据，满足条件返回true,不满足条件返回false,如下我们筛选出流中大于5小于10的数据 123456789void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream&lt;int&gt;.periodic(interval, (data) =&gt; data); stream = stream.where((data)=&gt;data&gt;5); stream = stream.where((data)=&gt; data&lt;10); await for(int i in stream)&#123; print(i); &#125; &#125; ​ stream.map 对流中的数据进行一些变换，以下是我对Stream的每个数据都加1 12345678void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream&lt;int&gt; stream = Stream&lt;int&gt;.periodic(interval, (data) =&gt; data); stream = stream.map((data) =&gt; data + 1); await for (int i in stream) &#123; print(i); &#125; &#125; ​ Stream.expand 对流中的数据进行一个扩展，如下，会输出1,1,2,2,3,3…. 123456void _stream() async &#123; Duration interval = Duration(seconds: 1); Stream stream = Stream.periodic(interval, (data) =&gt; data); stream = stream.expand((data)=&gt;[data,data]); stream.listen((data)=&gt;print(data),onError:(error)=&gt; print(\"发生错误\") ); &#125; ​ Stream.transform 如果我们在在流流转的过程中需要进行一些转换和控制我们则需要使用到transform,接收一个 StreamTransformer&lt;S,T&gt;，S表示转换之前的类型，T表示转换后的输入类型，如下代码我们会接收到三组数字模拟输入了三次密码，并判断真确的密码，同时输出密码正确和密码错误： 12345678910111213void _stream() async &#123; var stream = Stream&lt;int&gt;.fromIterable([123456,234567,678901]); var st = StreamTransformer&lt;int, String&gt;.fromHandlers( handleData: (int data, sink) &#123; if (data == 678901) &#123; sink.add(\"密码输入正确,正在开锁。。。\"); &#125; else &#123; sink.add(\"密码输入错误...\"); &#125; &#125;); stream.transform(st).listen((String data) =&gt; print(data), onError: (error) =&gt; print(\"发生错误\")); &#125; 输入如下结果 123I/flutter (18980): 密码输入错误...I/flutter (18980): 密码输入错误...I/flutter (18980): 密码输入正确,正在开锁。。。 ​ StreamController使用 ​ 介绍完了Stream的基本概念和基本用法，上面直接创建流的方式，对我们本身开发来说，用途不是很大，我们在实际的开发过程中，基本都是使用的StreamContoller来创建流。通过源码我们可以知道Stream的几种构造方法，最终都是通过StreamController进行了包装。 ​ 创建StreamController对象及使用 构建单订阅的Streamcontroller 123456789//StreamController里面会创建一个Stream，我们实际操控的StreamStreamController&lt;String&gt; streamController = StreamController();streamController.stream.listen((data)=&gt; print(data));streamController.sink.add(\"aaa\");streamController.add(\"bbb\");streamController.add(\"ccc\");streamController.close();//上面代码我们会输出 aaa,bbb,ccc 注意：如果我们给上面的代码再加一个listen会报如下异常,所以单订阅流，只能有一个listen。一般情况下我们多数都是使用的单订阅流，我们也可以将单订阅流转成多订阅流。 ​ 构建多监听器的StreamController有两种方式 1.直接创建多订阅Stream 12345678910StreamController&lt;String&gt; streamController = StreamController.broadcast(); streamController.stream.listen((data)&#123; print(data); &#125;,onError: (error)&#123; print(error.toString()); &#125;); streamController.stream.listen((data) =&gt; print(data)); streamController.add(\"bbb\"); //上面代码回输出 bbb,bbb 2.将单订阅流转成多订阅流 12345678StreamController&lt;String&gt; streamController = StreamController(); Stream stream =streamController.stream.asBroadcastStream(); stream.listen((data) =&gt; print(data)); stream.listen((data) =&gt; print(data)); streamController.sink.add(&quot;aaa&quot;); streamController.close(); //上面代码会输出 aaa,aaa 注意：在流用完了之后记得关闭，调用streamController.close() ​ StreamBuilder使用 ​ 前面我把Stream的常用方式做了简单的介绍和演示，我们怎么结合Flutter使用呢？在Flutter里面提供了一个Widget名叫StreamBuilder,StreamBuilder其实是个StatefulWidget它一直记录着流中最新的数据，当数据流发生变化时，会自动调用builder方法进行重建。 ​ StreamBuilder的源码如下，需要接受一个流，我们可以传入一个StreamController的Stream 1234567const StreamBuilder(&#123; Key key, this.initialData, Stream&lt;T&gt; stream, @required this.builder, &#125;) : assert(builder != null), super(key: key, stream: stream); ​ 使用StreamController 结合 StreamBuider对官方的计数器进行改进，取代setState刷新页面，代码如下 12345678910111213141516171819202122232425262728293031323334353637class MyHomePage extends StatefulWidget &#123; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _count = 0; final StreamController&lt;int&gt; _streamController = StreamController(); @override Widget build(BuildContext context) &#123; return Scaffold( body: Container( child: Center( child: StreamBuilder&lt;int&gt;( stream: _streamController.stream, builder: (BuildContext context, AsyncSnapshot snapshot) &#123; return snapshot.data == null ? Text(\"0\") : Text(\"$&#123;snapshot.data&#125;\"); &#125;), ), ), floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: () &#123; _streamController.sink.add(++_count); &#125;), ); &#125; @override void dispose() &#123; _streamController.close(); super.dispose(); &#125;&#125; ​ 源码相关 从StreamController源码我们可以看出来里面创建的得过程 默认创建一个_SyncStreamController,具体可以去读取下源码，看看StreamController是怎么创建Stream和StreamSink 12345678910factory StreamController( &#123;void onListen(), void onPause(), void onResume(), onCancel(), bool sync: false&#125;) &#123; return sync ? new _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel) : new _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel); &#125; 注意：上面我既使用了streamController.sink.add(&quot;aaa&quot;);添加数据，也使用了streamController.add(&quot;bbb&quot;);方式添加数据。实际效果是一样的，查看源码可知 sink如下,实际上sink是对StreamController的一种包装，最终都是调取的StreamController.add方法； 12345678910111213141516class _StreamSinkWrapper&lt;T&gt; implements StreamSink&lt;T&gt; &#123; final StreamController _target; _StreamSinkWrapper(this._target); void add(T data) &#123; _target.add(data); &#125; void addError(Object error, [StackTrace stackTrace]) &#123; _target.addError(error, stackTrace); &#125; Future close() =&gt; _target.close(); Future addStream(Stream&lt;T&gt; source) =&gt; _target.addStream(source); Future get done =&gt; _target.done; ​ 总结&nbsp;&nbsp;&nbsp;&nbsp;以上是我在开发过程中，对Flutter中Stream使用的一些简单的认识和常用方法的总结,StreamBuilder和 StreamController结合使用，实现局部刷新效果（比喻一个页面有多个接口，各自应该刷新自己控制的UI的部分而不应该整个页面刷新，时候我们可以使用StreamController和StreamBuilder达到这种效果）如有不到之处或者有偏差的地方，望指正~","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"Stream","slug":"Stream","permalink":"http://yoursite.com/tags/Stream/"},{"name":"StreamBuilder","slug":"StreamBuilder","permalink":"http://yoursite.com/tags/StreamBuilder/"}]},{"title":"Flutter NestedScrollView使用","slug":"Flutter-NestedScrollView使用","date":"2019-06-13T02:11:11.000Z","updated":"2019-09-26T03:12:10.778Z","comments":true,"path":"2019/06/13/Flutter-NestedScrollView使用/","link":"","permalink":"http://yoursite.com/2019/06/13/Flutter-NestedScrollView使用/","excerpt":"​ 前言​ 在我们使用开发Android的过程中总是遇到一些联动的效果，在Android原生中NestedScrollView和Toolbar配合进行交互，进行很多折叠效果。在Flutter中也也是可以通过NestedScrollView进行折叠效果，不过Flutter中使用SliverAppBar来代替Toolbar。 ​ 说到SliverAppBar 我们就有必要了解下 Slivers家族，官网给出的Slivers家族主要是为了解决复杂的滑动嵌套布局。Slivers家族基本都是配合CustomScrollView来使用的的。 Slivers家族的成员还比较多，下面我对部分成员进行解释：","text":"​ 前言​ 在我们使用开发Android的过程中总是遇到一些联动的效果，在Android原生中NestedScrollView和Toolbar配合进行交互，进行很多折叠效果。在Flutter中也也是可以通过NestedScrollView进行折叠效果，不过Flutter中使用SliverAppBar来代替Toolbar。 ​ 说到SliverAppBar 我们就有必要了解下 Slivers家族，官网给出的Slivers家族主要是为了解决复杂的滑动嵌套布局。Slivers家族基本都是配合CustomScrollView来使用的的。 Slivers家族的成员还比较多，下面我对部分成员进行解释： 实现的效果图如下 CustomScrollView 官网给出的解释如下： ​ CustomScrollView是可以使用sliver来自定义滚动模型（效果）的widget。它可以包含多种滚动模型，举个例子，假设有一个页面，顶部需要一个GridView，底部需要一个ListView，而要求整个页面的滑动效果是统一的，即它们看起来是一个整体，如果使用GridView+ListView来实现的话，就不能保证一致的滑动效果，因为它们的滚动效果是分离的，所以这时就需要一个”胶水”，把这些彼此独立的可滚动widget（Sliver）”粘”起来，而CustomScrollView的功能就相当于“胶水”。 Slivers家族 Sliver有细片、小片之意，在Flutter中，Sliver通常指具有特定滚动效果的可滚动块。可滚动widget，如ListView、GridView等都有对应的Sliver实现如SliverList、SliverGrid等。对于大多数Sliver来说，它们和可滚动Widget最主要的区别是Sliver不会包含Scrollable Widget，也就是说Sliver本身不包含滚动交互模型 ，正因如此，CustomScrollView才可以将多个Sliver”粘”在一起，这些Sliver共用CustomScrollView的Scrollable，最终实现统一的滑动效果 SliverAppbar 构造函数如下 12345678910111213141516171819202122const SliverAppBar(&#123; Key key, this.leading, //在标题左侧显示的一个控件，通常为一个图标 this.automaticallyImplyLeading = true,//? 控制是否应该尝试暗示前导小部件为null this.title, //标题 this.actions, //右侧的操作菜单，最多三个 this.flexibleSpace, //可以展开的区域，通常是一个FlexibleSpaceBar this.bottom, //底部内容区域，通常是 TabBar this.elevation, //阴影 this.forceElevated = false, this.backgroundColor, //APP bar 的颜色，默认值为 ThemeData.primaryColor this.brightness, //Appbar的主题，有白色和黑色两种主题 this.iconTheme, //Appbar 上图标的颜色、透明度、和尺寸信息 this.textTheme, //Appbar 上的文字主题 this.primary = true, //此应用栏是否显示在屏幕顶部 this.centerTitle, //标题是否居中显示，默认值根据不同的操作系统 this.titleSpacing = NavigationToolbar.kMiddleSpacing,//横轴上标题内容 周围的间距 this.expandedHeight, //展开高度 this.floating = false, //是否随着滑动隐藏标题 this.pinned = false, //是否固定在顶部 this.snap = false, //与floating结合使用 &#125;) FlexibleSpaceBar 一般和SliverAppBar的 flexibleSpace 配合使用，collapseMode收起来的动画效果，CollapseMode.pin 直接推起来，CollapseMode.parallax 视差效果，CollapseMode.none 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class TabPage4 extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return TabPageDemo(); &#125;&#125;class TabPageDemo extends StatefulWidget &#123; @override _TabPageDemoState createState() =&gt; _TabPageDemoState();&#125;class _TabPageDemoState extends State&lt;TabPageDemo&gt; with SingleTickerProviderStateMixin &#123; TabController _tabController; ScrollController _scrollviewController; @override void initState() &#123; super.initState(); _tabController = TabController(length: 4, vsync: this); _scrollviewController = ScrollController(initialScrollOffset: 0.0); &#125; @override void dispose() &#123; _tabController.dispose(); _scrollviewController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Container( child: Scaffold( body: NestedScrollView( controller: _scrollviewController, headerSliverBuilder: (context, boxIsScrolled) &#123; return [ SliverAppBar( pinned: true, 是否固定在顶部 floating: true, elevation: 0.5, forceElevated: boxIsScrolled, expandedHeight: 240.0, flexibleSpace: FlexibleSpaceBar( collapseMode: CollapseMode.pin, //视差效果 background: Container( color: Colors.white, child: Column( children: &lt;Widget&gt;[ Container( height: 180.0, color: Colors.blue, child: Image.asset( \"assets/images/timg.jpeg\", fit: BoxFit.fill, ), ) ], ), ), ), bottom: TabBar(controller: _tabController, tabs: [ Tab( text: \"活动专题\", ), Tab( text: \"促销专栏\", ), Tab( text: \"新品上市\", ), Tab( text: \"精品推荐\", ) ]), ), ]; &#125;, body: TabBarView( controller: _tabController, children: [PageOne(), PageOne(), PageOne(), PageOne()])) ), ); &#125;&#125;","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"NestedScrollView","slug":"NestedScrollView","permalink":"http://yoursite.com/tags/NestedScrollView/"}]},{"title":"App启动白屏问题","slug":"App启动白屏问题","date":"2018-10-12T01:14:37.000Z","updated":"2019-09-26T03:13:27.021Z","comments":true,"path":"2018/10/12/App启动白屏问题/","link":"","permalink":"http://yoursite.com/2018/10/12/App启动白屏问题/","excerpt":"现象Android app启动页面不作任何特殊处理的话，会出现一瞬间的白屏现象。 页面加载一个布局layout的话，不做任何耗时处理，也会出现一瞬间的白屏或者黑屏现象，这主要看App设置的style样式。 点击Launcher桌面图标冷启动一个App的时候，程序需要进行一些基本的初始化动工作，Application或者SplashActivity中做了耗时操作，当手机性能不好，配置不高的时候，白屏(黑屏)现象尤其严重。","text":"现象Android app启动页面不作任何特殊处理的话，会出现一瞬间的白屏现象。 页面加载一个布局layout的话，不做任何耗时处理，也会出现一瞬间的白屏或者黑屏现象，这主要看App设置的style样式。 点击Launcher桌面图标冷启动一个App的时候，程序需要进行一些基本的初始化动工作，Application或者SplashActivity中做了耗时操作，当手机性能不好，配置不高的时候，白屏(黑屏)现象尤其严重。 原因当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态，于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是Preview Window，即预览窗口。 实际上就是是activity默认的主题中的android:windowBackground为白色或者黑色导致的。 总结来说启动顺序就是：app启动——Preview Window(也称为预览窗口)——启动页 解决方法1、方案分析 Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。所以，解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。 设置配置文件style样式中的windowBackground这个属性来显示一张背景图还有一个效果就是启动应用程序会感觉非常快，而且与加载MainActivity的contentView是异步的。 2.解决方式 方案1，给当前启动页面添加一个有背景的style样式，如下 12345678910111213&lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@mipmap/splash&lt;/item&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;&lt;/style&gt;//注意 在清单文件中配置&lt;activity android:name=&quot;.SplashActivity&quot; android:theme=&quot;@style/SplashTheme&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 将上面的App的主题设置到SplashActivity的主题中，windowBackGround就是即将展示的previewWindow，splash可以是一整张图片，也可以是解析出来的图片资源的xml文件，经过处理之后的App就不会出现一瞬间的黑屏或者白屏情况。 注意事项 给prewiew设置的的背景图如果不做处理，图片会一直存在于内存中，所以当我我们进入欢迎页面时，不要忘记把背景图片设为空。 123456@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; //将window的背景图设置为空 getWindow().setBackgroundDrawable(null); super.onCreate(savedInstanceState);&#125; 这样做如何做好屏幕适配 这样通过style设置的SplashActivity加载图，不能像ImageView设置缩放功能，但是可以使用 .9图。 设计好图，直接铺满全屏 方案2 禁止加载Preview Window，具体做法如下： 123&lt;style name=&quot;SplashTheme&quot; parent=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。个人感觉这种方法没有第一种好！ windowDisablePreview的作用，通过设置android:windowDisablePreview属性，禁用窗口的预览动画，在SplashActivity显示之前，系统永远不会使用窗口的主题来显示它的预览，这也保证了不会出现白屏或者黑屏。但是，与设置android:windowIsTranslucent属性一样，如果在SplashActivity启动的时候，有过多复杂的操作，就会出现在手机中点击了应用程序的图标，但过n秒才会打开应用程序不好的卡顿体验效果. 该方案的缺点 这种方法有个小缺点，就是点击后短暂的那几百毫秒没有反应，就好像“假死”了一样，过了一会儿才跳出我们应用程序的第一个Activity，如果你不想让你的 App 有这个短暂“假死”时间，建议使用第一种方法。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"启动白屏","slug":"启动白屏","permalink":"http://yoursite.com/tags/启动白屏/"},{"name":"theme","slug":"theme","permalink":"http://yoursite.com/tags/theme/"}]},{"title":"Android元素共享(Share Element Transition)","slug":"Android元素共享","date":"2017-08-10T14:27:42.000Z","updated":"2019-09-26T03:13:59.000Z","comments":true,"path":"2017/08/10/Android元素共享/","link":"","permalink":"http://yoursite.com/2017/08/10/Android元素共享/","excerpt":"&emsp;&emsp;由于在近期的项目项目中用到了元素的过渡动画，动画的目的当然是让交互更连贯，这里主要记录共享元素动画，查看了部分资料及个人理解和使用，特此记~&emsp;&emsp;这里主要是基于Android Lollipop(5.0以上,sdk 21)。 &emsp;&emsp;所谓共享元素可以这样理解，一个View或者多个View以平滑的方式从一个Activity都另一个Activity。 &emsp;&emsp;具体实现方式如下：","text":"&emsp;&emsp;由于在近期的项目项目中用到了元素的过渡动画，动画的目的当然是让交互更连贯，这里主要记录共享元素动画，查看了部分资料及个人理解和使用，特此记~&emsp;&emsp;这里主要是基于Android Lollipop(5.0以上,sdk 21)。 &emsp;&emsp;所谓共享元素可以这样理解，一个View或者多个View以平滑的方式从一个Activity都另一个Activity。 &emsp;&emsp;具体实现方式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571.在res中新建一个values-v21文件夹(这些动画都是基于Android5.0+)2.在values-v21中新建styles.xml3.在styles.xml中加入如下内容 自定义主题，同时允许transitions&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- 允许使用transitions --&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt; &lt;!--如果你在theme中没有指定windowContentTransitions,则可以在代码中设置 getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);--&gt; &lt;!--可以加入进入和退出的动画效果--&gt; &lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt; &lt;!--windowEnterTransition 可以用getWindow().setEnterTransition() 在代码中实现 --&gt; &lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt; &lt;!--windowExitTransition 可以用getWindow().setExitTransition(n) 在代码中实现 --&gt; &lt;!--是否覆盖执行，其实可以理解成是否同步执行还是顺序执行，是否是等前面的动画执行完了完再执行后面的动画--&gt; &lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;false&lt;/item&gt; &lt;!--以上两句可以在代码中用代码实现--&gt; &lt;!--getWindow().setWindowAllowEnterTransitionOverlap(false)--&gt; &lt;!--getWindow().setWindowAllowReturnTransitionOverlap(false)--&gt;&lt;/style&gt;4.设置共享的View的transitionName一致两种方式 ○通过xml文件进行配置，android:transitionName ○在java代码中设置共享的View view.setTransitionName(&quot;&quot;)5.设置启动或者跳转的动画 -- 设置单个view的共享 //设置要跳转的Activity Intent intent = new Intent(this, YourSecondActivity.class); //获取要share的View 的transitionName String transitionName = getString(R.string.transition_string); //获取当前要共享的View View shareView = findViewById(R.id.share_view); //设置Options ActivityOptionsCompat.makeSceneTransitionAnimation(this, shareView, // share View transitionName //transitionName ); //启动跳转 ActivityCompat.startActivity(this, intent, options.toBundle()); --设置多个View共享的方式 //设置要跳转的Activity Intent intent = new Intent(this, YourSecondActivity.class); Pair&lt;View, String&gt; p1 = Pair.create(shareView1, &quot;share1&quot;); Pair&lt;View, String&gt; p2 = Pair.create(shareView2, &quot;share2&quot;); Pair&lt;View, String&gt; p3 = Pair.create(shareView3, &quot;share3&quot;); //设置启动options ActivityOptionsCompat options = ActivityOptionsCompat. makeSceneTransitionAnimation(this, p1, p2, p3); //启动跳转 ActivityCompat.startActivity(this, intent, options.toBundle()); 以上这些基本跳转动画已配置完成。可以直接食用了~ 这是正常情况下，但是很多时候我们碰到的都是跳转过去再请求网络数据，这就存在一个延迟加载的过程。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Transition","slug":"Transition","permalink":"http://yoursite.com/tags/Transition/"}]},{"title":"ObjectBox简记","slug":"ObjectBox简记","date":"2017-08-08T14:18:22.000Z","updated":"2019-09-26T03:18:16.459Z","comments":true,"path":"2017/08/08/ObjectBox简记/","link":"","permalink":"http://yoursite.com/2017/08/08/ObjectBox简记/","excerpt":"这两天听朋友说起了最近Android出来了一个NoSql数据库ObjectBox，怀揣着好奇就建了一个Android程序进行了简单的运用和测试，感觉效果很好，特此记~ 此文主要供 Kotlin使用ObjectBox 1.添加依赖 在project的build.gradle添加如下配置123456789101112131415161718192021222324buildscript &#123; //目前版本是1.4.1 ext.objectboxVersion = &apos;1.4.1&apos; ext.kotlin_version = &apos;1.2.10&apos; repositories &#123; google() jcenter() maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.1&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot; &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125;&#125;","text":"这两天听朋友说起了最近Android出来了一个NoSql数据库ObjectBox，怀揣着好奇就建了一个Android程序进行了简单的运用和测试，感觉效果很好，特此记~ 此文主要供 Kotlin使用ObjectBox 1.添加依赖 在project的build.gradle添加如下配置123456789101112131415161718192021222324buildscript &#123; //目前版本是1.4.1 ext.objectboxVersion = &apos;1.4.1&apos; ext.kotlin_version = &apos;1.2.10&apos; repositories &#123; google() jcenter() maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.1&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot; &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125;&#125; 在app的build.gradle中需要添加如下配置 123456789101112131415161718192021222324apply plugin: &apos;com.android.application&apos;apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos;apply plugin: &apos;kotlin-kapt&apos;//此依赖主要用于browser，可以在浏览器中查看app的数据dependencies &#123; debugImplementation &quot;io.objectbox:objectbox-android-objectbrowser:$objectboxVersion&quot; releaseImplementation &quot;io.objectbox:objectbox-android:$objectboxVersion&quot;&#125;//一定要在 上面两个依赖之下 此pluginapply plugin: &apos;io.objectbox&apos; // after applying Android plugin//在正常的dependencies中添加如下依赖dependencies&#123;//主要是针对kotlincompile &quot;io.objectbox:objectbox-kotlin:$objectboxVersion&quot;&#125; 在应用中的正常使用(建议在Applicaion中初始化),以下是初始化（我也是初学kotlin可能存在一些语法不够简洁，不喜勿喷哈）： 123456789101112131415161718192021222324class App : Application() &#123; override fun onCreate() &#123; super.onCreate() initObjectBox() &#125; //定义静态块 静态方法 companion object &#123; lateinit var boxStore: BoxStore fun getBoxStoreInstance() = boxStore &#125; private fun initObjectBox() &#123; boxStore = MyObjectBox.builder().androidContext(this).build() if (BuildConfig.DEBUG) &#123; boxStore?.let &#123; //可以理解为初始化连接浏览器(可以在浏览器中查看数据，下面再说) val started = AndroidObjectBrowser(boxStore).start(this) Log.i(&quot;ObjectBrowser&quot;, &quot;Started: &quot; + started) &#125; &#125; &#125;&#125; 创建实体类 123456789101112131415161718192021//实体类学生@Entityclass Student&#123; @Id var id:Long = 0 lateinit var name:String //这里是假设学生和老师的关系(relation)是一对一 lateinit var teacher:ToOne&lt;Teacher&gt;&#125;//实体类老师@Entityclass Teacher&#123; @Id var id:Long =0 lateinit var name:String //这里假设老师和学生的关系是一对多(一个老师有多个学生) @Backlink lateinit var students: ToMany&lt;Student&gt;&#125; 基本使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//此处是我在Application里面做了初始化操作var boxStore = App.getBoxStoreInstance()//如果没有在Application里面初始化，使用的地方初始化可以这样操作，MyObjectBox需要build工程之后才会出来//var boxStore = MyObjectBox.builder().androidContext(this).build()var studentBox: Box&lt;Student&gt; = boxStore.boxFor&lt;Student&gt;()var teacherBox: Box&lt;Teacher&gt; = boxStore.boxFor&lt;Teacher&gt;()//创建一个老师对象和一个学生对象var teacher = Teacher()teacher.name = &quot;我是老师&quot;//学生和老师的relation是1对1 如果没有关系则不用这一步//student.teacher.target = teachervar student = Student()student.name = &quot;我是学生&quot;//创建一个学生列表var allStudents: MutableList&lt;Student&gt; = mutableListOf()//老师和学生是一对多的关系，不用relation则可以不用次关系teacher.students.addAll(allStudents)//以下是对数据的基本操作//- 添加数据(可以单个数据添加，也可以添加一个列表数据)studentBox.put(student)studentBox.put(mutableListOf())//查询数据的几种方式1.get方式查询数据(可以传入id，id列表等等，具体查看api)var student=studentBox.get(id)2.find方式(传入你Entity对应的属性和值进行查询，Student_构建会自动生成)var findStudents: List&lt;Student&gt; = studentBox.find(Student_.name, &quot;张三&quot;)3.query方式(适用于复杂查询可以拼接各种条件，如下简单拼接)var queryStudents: List&lt;Student&gt; = studentBox.query() .equal(Student_.name, &quot;张三&quot;) .between(Student_.id, 1, 10) .build() .find();//更新数据的操作和插入的操作相同都是putstudentBox.put(student)//删除数据的操作(可以单个id，多个id，单个对象，对象列表等)studentBox.remove(id)studentBox.remove(id1,id2...)studentBox.remove(student)studentBox.remove(mutableListOf()) 其他操作(browser查看数据)，上面依赖其实已经添加过也加了注释，但是在这还是做个补充吧. 123456789101112131415161718192021222324252627//1.app的build.gradle中加入如下依赖dependencies &#123; debugImplementation &quot;io.objectbox:objectbox-android-objectbrowser:$objectboxVersion&quot; releaseImplementation &quot;io.objectbox:objectbox-android:$objectboxVersion&quot;&#125;//一定要在 上面两个依赖之下 此pluginapply plugin: &apos;io.objectbox&apos;//2.代码中加入如下代码（加入到初始化之后）if (BuildConfig.DEBUG) &#123; boxStore?.let &#123; val started = AndroidObjectBrowser(boxStore).start(this) Log.i(&quot;ObjectBrowser&quot;, &quot;Started: &quot; + started) &#125;//3.在manifest中添加网络访问权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;4.以上已经完成基本浏览数据的配置，如果Android手机当前引用的消息通知是打开的会打开的,则会收到一条通知点击通知则浏览器会打开数据浏览。如果需要浏览器打开则需要转发端口adb forward tcp:8090 tcp:8090浏览器可以访问 http://localhost:8090/index.html 直接打开 温馨提示 1231.@Id var id:Long =0 表示ID从1开始 自增长 且必须指定为Long类型2.数据的存储位置为/data/data/com.xx.xx(应用包名)/objectbox/ 如上即学习ObjectBox一点简记，如有错误欢迎指正~","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"NoSql","slug":"NoSql","permalink":"http://yoursite.com/tags/NoSql/"}]}]}